{"version":3,"file":"index.js","sources":["../src/components/ChunkLoadError.tsx","../src/components/Loading.tsx","../src/components/LazyCompoent.tsx","../src/hooks/useHeight.tsx","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/utils/Factory.tsx","../src/utils/importGlob.tsx","../src/hocs/withNcLayout.tsx","../src/utils/history.tsx","../src/routes.tsx","../src/components/Link.tsx","../src/components/HistoryRouter.tsx"],"sourcesContent":["// TODO viết 1 component đẹp hơn để thông báo việc lỗi chunk load\nimport React from 'react'\n\nconst ChunkLoadError: React.FC<{ error?: string; onReload: () => void }> = React.memo(\n  ({ onReload, error }) => (\n    <React.Fragment>\n      {error} <button onClick={onReload}>Re-fetch</button>\n    </React.Fragment>\n  )\n)\n\nexport { ChunkLoadError }\n","import React from 'react'\nimport { Loading as NcLoading } from 'nc-simple-loading'\nimport styled from 'styled-components'\n\nconst Loading = React.memo(() => (\n  <LoadingContainer>\n    <NcLoading />\n  </LoadingContainer>\n))\n\nexport { Loading }\n\nconst LoadingContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  z-index: 999999999;\n  background: white;\n  display: flex;\n  align-items: center;\n  justify-contents: space-between;\n`\n","import React, { useCallback, useLayoutEffect } from 'react'\nimport { useBoolean } from 'ahooks'\nimport { Factory } from '../utils/Factory'\nimport { ChunkLoadError } from './ChunkLoadError'\nimport { Loading } from './Loading'\n\nconst delay = (ms?: number) => new Promise((resolve) => setTimeout(resolve, ms || 1000))\n\nconst LazyComponent: React.FC<React.PropsWithChildren<{ factory: Factory }>> = React.memo(\n  ({ factory, children }) => {\n    const [isLoading, { setTrue: onLoading, setFalse: offLoading }] = useBoolean(!factory.isFetched)\n\n    const fetch = useCallback(() => {\n      if (factory.isFetched) return\n\n      onLoading()\n      Promise.all([delay(), factory.fetch()]).finally(offLoading)\n    }, [factory.isFetched])\n\n    useLayoutEffect(fetch, [factory.isFetched])\n\n    if (isLoading) return <Loading />\n    if (factory.error) return <ChunkLoadError error={factory.error} onReload={fetch} />\n    return <factory.Component>{children}</factory.Component>\n  }\n)\n\nexport { LazyComponent }\n","import { useMemo, useRef } from 'react'\nimport { useSize } from 'ahooks'\n\nconst useHeight = (): [React.MutableRefObject<null>, number] => {\n  const ref = useRef(null)\n  const size = useSize(ref)\n  const height = useMemo(() => size?.height || 0, [size])\n  return [ref, height]\n}\n\nexport { useHeight }\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React, { memo } from 'react'\nimport { Loading } from '../components/Loading'\n\ntype T_FactoryReturn = () => Promise<{\n  default: React.FC<any> & {\n    factories?: Factory[]\n  }\n}>\n\nclass Factory {\n  factory: T_FactoryReturn\n  isFetched: boolean = false\n  Component: React.FC<any> = Loading\n  error: string = ''\n\n  constructor(factory: T_FactoryReturn) {\n    this.factory = factory\n  }\n\n  fetch = async () => {\n    try {\n      const { default: Component } = await this.factory()\n\n      if (Component.factories) {\n        Promise.all(Component.factories.map((f) => f.fetch()))\n      }\n\n      this.Component = memo(Component)\n      this.isFetched = true\n      this.error = ''\n    } catch (e) {\n      console.error('[nc-toolkits]', e.message)\n      this.error = e.message\n    }\n  }\n}\n\nexport { Factory }\nexport type { T_FactoryReturn }\n","import _ from 'lodash'\nimport { T_FactoryReturn } from './Factory'\n\nconst importGlob = (basePath: string) => {\n  const data = _.pickBy(\n    // @ts-expect-error\n    import.meta.glob('/src/{layouts,pages}/**/*.tsx'),\n    function (__val, key) {\n      return _.startsWith(key, basePath)\n    }\n  )\n\n  const output: Record<string, T_FactoryReturn> = {}\n\n  for (const key in data) {\n    const baseName = key\n      .replace(basePath, '')\n      .replace(/\\.tsx$/, '')\n      .replace(/^\\//, '')\n\n    output[baseName] = data[key]\n  }\n\n  return output\n}\n\nexport { importGlob }\n","import React, { FC, Fragment, memo } from 'react'\nimport _ from 'lodash'\nimport styled from 'styled-components'\nimport { LazyComponent } from '../components/LazyCompoent'\nimport { useHeight } from '../hooks/useHeight'\nimport { Factory } from '../utils/Factory'\nimport { importGlob } from '../utils/importGlob'\n\nconst getLayoutCollections = (component: 'headers' | 'footers' | 'contents') => {\n  const output: Record<string, Factory> = {}\n  const importedCompoents = importGlob(`/src/layouts/${component}`)\n\n  for (const componentPath in importedCompoents) {\n    output[componentPath] = new Factory(importedCompoents[componentPath])\n  }\n\n  return output\n}\n\nconst getLayoutFactory = (\n  component: 'headers' | 'footers' | 'contents',\n  name: string\n): Factory | null => {\n  const collections = getLayoutCollections(component)\n  if (name === 'none' || !collections) return null\n\n  return collections[name] || collections['index'] || null\n}\n\nconst withNcLayout = (\n  Component: FC,\n  options?: {\n    header?: string\n    content?: string\n    footer?: string\n  }\n) => {\n  const MemoComponent = memo(Component)\n  const headerFactory = getLayoutFactory('headers', options?.header || 'index')\n  const contentFactory = getLayoutFactory('contents', options?.content || 'index')\n  const footerFactory = getLayoutFactory('footers', options?.footer || 'index')\n\n  const ReturnedComponent: FC & { factories?: Factory[] } = () => {\n    const [headerRef, headerHeight] = useHeight()\n    const [footerRef, footerHeight] = useHeight()\n\n    return (\n      <Fragment>\n        {headerFactory && (\n          <Header ref={headerRef}>\n            <LazyComponent factory={headerFactory} />\n          </Header>\n        )}\n\n        {contentFactory ? (\n          <Main headerHeight={headerHeight} footerHeight={footerHeight}>\n            <LazyComponent factory={contentFactory}>\n              <MemoComponent />\n            </LazyComponent>\n          </Main>\n        ) : (\n          <main>\n            <MemoComponent />\n          </main>\n        )}\n\n        {footerFactory && (\n          <footer ref={footerRef}>\n            <LazyComponent factory={footerFactory} />\n          </footer>\n        )}\n      </Fragment>\n    )\n  }\n\n  _.set(\n    ReturnedComponent,\n    'factories',\n    [headerFactory, contentFactory, footerFactory].filter((f) => f)\n  )\n\n  return ReturnedComponent\n}\n\nconst Main = styled.main`\n  min-height: ${({\n    headerHeight = 0,\n    footerHeight = 0,\n  }: {\n    headerHeight?: number\n    footerHeight?: number\n  }) => `calc(100vh - ${headerHeight + footerHeight}px)`};\n`\n\nconst Header = styled.header`\n  position: sticky;\n  top: 0;\n  left: 0;\n  background: white;\n  box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n`\n\nexport { withNcLayout }\n","import { createBrowserHistory } from 'history'\n\nconst history = createBrowserHistory()\nexport { history }\n","import React from 'react'\nimport _ from 'lodash'\nimport { LazyComponent } from './components/LazyCompoent'\nimport { Factory } from './utils/Factory'\nimport { importGlob } from './utils/importGlob'\n\nconst pathConvert = (path: string) => ['/', path.replace(/index$/, '').toLowerCase()].join('')\nconst slugConvert = (path: string) => path.split(/\\]/).join('').split(/\\/\\[/).join('/:') // thay thees /[slug] thành /:slug\n\nconst pagePathToRoutePath = (pagePath: string) => {\n  const pathWithSlugRegex = /^(\\/[a-z][^\\]/\\s]*|\\/\\[[a-z][^/\\s]*\\])+$|^\\/$/g\n  let path = pathConvert(pagePath)\n\n  if (!pathWithSlugRegex.test(path)) {\n    console.warn('[nc-toolkits]', pagePath, 'is invalid path.')\n    return null\n  } // không tạo route nếu không đúng định dạng\n\n  path = slugConvert(path)\n  return path\n}\n\nconst getRoutes = () => {\n  const importedPages = importGlob('/src/pages')\n  const imported404Page = importGlob('/src/pages/404.tsx')['']\n  const output = []\n\n  for (const pagePath in importedPages) {\n    const path = pagePathToRoutePath(pagePath)\n    if (path) {\n      const factory = new Factory(importedPages[pagePath])\n\n      output.push({\n        path,\n        factory,\n        element: <LazyComponent factory={factory} />,\n      })\n    }\n  }\n\n  const routes = output.map((o) => _.pick(o, ['path', 'element']))\n  const routePreloads = output.map((o) => _.pick(o, ['path', 'factory']))\n\n  // @ts-expect-error\n  if (imported404Page) {\n    const page404Factory = new Factory(importGlob('/src/pages/404.tsx')[''])\n\n    routes.push({\n      path: '*',\n      element: <LazyComponent factory={page404Factory} />,\n    })\n  }\n\n  return {\n    routes,\n    routePreloads,\n  }\n}\n\nconst { routes, routePreloads } = getRoutes()\n\nexport { routePreloads, routes }\n","import React, { useEffect, useMemo, useRef } from 'react'\nimport { useInViewport } from 'ahooks'\nimport { matchPath, Link as DefaultLink } from 'react-router-dom'\nimport { routePreloads } from '../routes'\n\nconst Link: typeof DefaultLink = React.memo(\n  React.forwardRef((props, forwardedRef) => {\n    // @ts-expect-error\n    const ref = useRef(forwardedRef?.current || forwardedRef || null)\n    const [inViewport] = useInViewport(ref)\n\n    const targetPath: string = useMemo(\n      () => (typeof props.to === 'string' ? props.to : props.to.pathname) as string,\n      [JSON.stringify(props.to)]\n    )\n\n    const currentRoute = useMemo(\n      () => routePreloads.find((r) => matchPath(r.path, targetPath)),\n      [targetPath]\n    )\n\n    useEffect(() => {\n      if (!inViewport) return // không thực hiện nếu link chưa hiển thị trên màn hình\n      if (!currentRoute || !currentRoute.factory) return // không thực hiện nếu không tìm được route\n      if (currentRoute.factory.isFetched) return // không thực hiện gì nếu đã được preload\n\n      currentRoute.factory.fetch()\n    }, [inViewport])\n\n    return <DefaultLink {...props} ref={ref} />\n  })\n)\n\nexport { Link }\n","import React, { NamedExoticComponent, memo } from 'react'\nimport { unstable_HistoryRouter as UnstableHistoryRouter, useRoutes } from 'react-router-dom'\nimport { routes } from '../routes'\nimport { history } from '../utils/history'\n\nconst Routes = memo(() => useRoutes(routes))\n\nconst HistoryRouter: NamedExoticComponent = memo(() => (\n  // @ts-expect-error\n  <UnstableHistoryRouter history={history}>\n    <Routes />\n  </UnstableHistoryRouter>\n))\n\nexport { HistoryRouter }\n"],"names":["React","memo","Fragment","error","onClick","onReload","LoadingContainer","NcLoading","styled","div","factory","children","useBoolean","isFetched","isLoading","onLoading","setTrue","offLoading","setFalse","useCallback","Promise","all","resolve","fetch","useLayoutEffect","Loading","ChunkLoadError","Component","useRef","useSize","ref","useMemo","size","height","Symbol","iterator","asyncIterator","this","body","recover","result","_this","factories","map","f","e","then","console","message","basePath","_","pickBy","import","__val","key","startsWith","output","replace","data","component","name","importGlob","componentPath","importedCompoents","getLayoutCollections","collections","main","headerHeight","footerHeight","header","createBrowserHistory","pagePath","path","toLowerCase","join","pathConvert","test","split","slugConvert","warn","pagePathToRoutePath","importedPages","push","element","LazyComponent","o","pick","imported404Page","routes","page404Factory","routePreloads","getRoutes","forwardRef","props","forwardedRef","current","inViewport","useInViewport","to","pathname","JSON","stringify","find","r","targetPath","useEffect","currentRoute","DefaultLink","UnstableHistoryRouter","history","Routes","options","getLayoutFactory","content","footer","useHeight","headerRef","footerRef","headerFactory","Header","contentFactory","Main","MemoComponent","footerFactory","set","ReturnedComponent","filter"],"mappings":"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"}