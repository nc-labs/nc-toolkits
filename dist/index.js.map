{"version":3,"file":"index.js","sources":["../src/hooks/useWatcher.tsx","../src/utils/history.tsx","../src/components/ChunkLoadError.tsx","../src/components/Loading.tsx","../src/components/LazyCompoent.tsx","../src/utils/delay.tsx","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/utils/Factory.tsx","../src/utils/importGlob.tsx","../src/utils/getRoutes.tsx","../src/routes.tsx","../src/components/Link.tsx","../src/hooks/useHeight.tsx","../src/utils/getLayoutCollections.tsx","../src/components/LayoutComponent.tsx","../src/components/Router.tsx","../src/constants/customEvents.tsx","../src/hocs/withLayout.tsx"],"sourcesContent":["import { useEventListener } from 'ahooks'\n\nconst watcher = {\n  useWatcher: <T,>(name: string, listener: (data: T) => void) => {\n    // @ts-expect-error\n    useEventListener(name, ({ detail }: { detail: T }) => {\n      listener(detail)\n    })\n  },\n  emitWatcher: <T,>(name: string, data: T) =>\n    window.dispatchEvent(new CustomEvent(name, { detail: data })),\n}\n\nexport { watcher }\n","import { createBrowserHistory } from 'history'\n\nconst history = createBrowserHistory()\nexport { history }\n","// TODO viết 1 component đẹp hơn để thông báo việc lỗi chunk load\nimport React from 'react'\n\nconst ChunkLoadError: React.FC<{ error?: string; onReload: () => void }> = React.memo(\n  ({ onReload, error }) => (\n    <React.Fragment>\n      {error} <button onClick={onReload}>Re-fetch</button>\n    </React.Fragment>\n  )\n)\n\nexport { ChunkLoadError }\n","import React from 'react'\nimport { Loading as NcLoading } from 'nc-simple-loading'\nimport styled from 'styled-components'\n\nconst Loading = React.memo(() => (\n  <LoadingContainer>\n    <NcLoading />\n  </LoadingContainer>\n))\n\nexport { Loading }\n\nconst LoadingContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  z-index: 999999999;\n  background: white;\n  display: flex;\n  align-items: center;\n  justify-contents: space-between;\n`\n","import React, { useCallback, useLayoutEffect } from 'react'\nimport { useBoolean } from 'ahooks'\nimport { delay } from '../utils/delay'\nimport { Factory } from '../utils/Factory'\nimport { ChunkLoadError } from './ChunkLoadError'\nimport { Loading } from './Loading'\n\nconst LazyComponent: React.FC<React.PropsWithChildren<{ factory: Factory }>> = React.memo(\n  ({ factory, children }) => {\n    const [isLoading, { setTrue: onLoading, setFalse: offLoading }] = useBoolean(!factory.isFetched)\n\n    const fetch = useCallback(() => {\n      if (factory.isFetched) return\n\n      onLoading()\n      Promise.all([delay(), factory.fetch()]).finally(offLoading)\n    }, [factory.isFetched])\n\n    useLayoutEffect(fetch, [factory.isFetched])\n    if (isLoading) return <Loading />\n    if (factory.error) return <ChunkLoadError error={factory.error} onReload={fetch} />\n    return <factory.Component>{children}</factory.Component>\n  }\n)\n\nexport { LazyComponent }\n","const delay = (ms?: number) => new Promise((resolve) => setTimeout(resolve, ms || 1000))\n\nexport { delay }\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from 'react'\nimport { Loading } from '../components/Loading'\nimport { T_Factory } from './lazy'\n\nclass Factory {\n  factory: T_Factory\n  isFetched: boolean = false\n  Component: React.FC<any> = Loading\n  error: string = ''\n\n  constructor(factory: T_Factory) {\n    this.factory = factory\n  }\n\n  fetch = async () => {\n    const maxTryTimes = 3 // cho phép fetch tối đa 3 lần\n\n    for (let index = 0; index < maxTryTimes; index++) {\n      try {\n        const { default: Component } = await this.factory()\n        this.Component = Component\n        this.isFetched = true\n        this.error = ''\n        break // nếu fetch thành công thì done luôn không cần thử lại\n      } catch (e) {\n        if (index !== maxTryTimes - 1) continue // nếu chưa phải lần fetch cuối cùng thì không làm gì cả, để vòng for tự tăng và thử load lại lần nữa\n\n        // đây là lần fetch cuối cùng, tức là 3 lần liên tiếp fetch bị lỗi\n        console.error('[nc-toolkits]', e.message)\n        this.error = e.message\n      }\n    }\n  }\n}\n\nexport { Factory }\n","import _ from 'lodash'\nimport { T_Factory } from './lazy'\n\nconst importGlob = (basePath: string) => {\n  // @ts-expect-error\n  const data = _.pickBy(import.meta.glob('/src/{layouts,pages}/**/*.tsx'), function (__val, key) {\n    return _.startsWith(key, basePath)\n  })\n\n  const output: Record<string, T_Factory> = {}\n\n  for (const key in data) {\n    const baseName = key\n      .replace(basePath, '')\n      .replace(/\\.tsx$/, '')\n      .replace(/^\\//, '')\n\n    output[baseName] = () => import(`${key}?t=${Date.now()}`)\n  }\n\n  return output\n}\n\nexport { importGlob }\n","import React from 'react'\nimport _ from 'lodash'\nimport { LazyComponent } from '../components/LazyCompoent'\nimport { Factory } from './Factory'\nimport { importGlob } from './importGlob'\n\nconst pathConvert = (path: string) => ['/', path.replace(/index$/, '').toLowerCase()].join('')\nconst slugConvert = (path: string) => path.split(/\\]/).join('').split(/\\/\\[/).join('/:') // thay thees /[slug] thành /:slug\n\n// TODO xử lý trường hợp 2 slug trùng tên\nconst getRoutes = () => {\n  const importedPages = importGlob('/src/pages')\n  const output = []\n\n  for (const pagePath in importedPages) {\n    const pathWithSlugRegex = /^(\\/[a-z][^\\]/\\s]*|\\/\\[[a-z][^/\\s]*\\])+$|^\\/$/g\n    let path = pathConvert(pagePath)\n\n    if (!pathWithSlugRegex.test(path)) {\n      console.warn('[nc-toolkits]', pagePath, 'is invalid path.')\n      continue\n    } // không tạo route nếu không đúng định dạng\n\n    path = slugConvert(path)\n    const factory = new Factory(importedPages[pagePath])\n\n    output.push({\n      path,\n      factory,\n      element: <LazyComponent factory={factory} />,\n    })\n  }\n\n  return {\n    routes: output.map((o) => _.pick(o, ['path', 'element'])),\n    routePreloads: output.map((o) => _.pick(o, ['path', 'factory'])),\n  }\n}\n\nexport { getRoutes }\n","import { getRoutes } from './utils/getRoutes'\n\nconst { routes, routePreloads } = getRoutes()\n\nexport { routePreloads, routes }\n","import React, { useEffect, useMemo, useRef } from 'react'\nimport { useInViewport } from 'ahooks'\nimport { matchPath, Link as DefaultLink } from 'react-router-dom'\nimport { routePreloads } from '../routes'\n\nconst Link: typeof DefaultLink = React.memo(\n  React.forwardRef((props, forwardedRef) => {\n    // @ts-expect-error\n    const ref = useRef(forwardedRef?.current || forwardedRef || null)\n    const [inViewport] = useInViewport(ref)\n\n    const targetPath: string = useMemo(\n      () => (typeof props.to === 'string' ? props.to : props.to.pathname) as string,\n      [JSON.stringify(props.to)]\n    )\n\n    const currentRoute = useMemo(\n      () => routePreloads.find((r) => matchPath(r.path, targetPath)),\n      [targetPath]\n    )\n\n    useEffect(() => {\n      if (!inViewport) return // không thực hiện nếu link chưa hiển thị trên màn hình\n      if (!currentRoute || !currentRoute.factory) return // không thực hiện nếu không tìm được route\n      if (currentRoute.factory.isFetched) return // không thực hiện gì nếu đã được preload\n\n      currentRoute.factory.fetch()\n    }, [inViewport])\n\n    return <DefaultLink {...props} ref={ref} />\n  })\n)\n\nexport { Link }\n","import { useMemo, useRef } from 'react'\nimport { useSize } from 'ahooks'\n\nconst useHeight = (): [React.MutableRefObject<null>, number] => {\n  const ref = useRef(null)\n  const size = useSize(ref)\n  const height = useMemo(() => size?.height || 0, [size])\n  return [ref, height]\n}\n\nexport { useHeight }\n","import { Factory } from './Factory'\nimport { importGlob } from './importGlob'\n\nconst getLayoutCollections = (component: 'headers' | 'footers' | 'contents') => {\n  const output: Record<string, Factory> = {}\n  const importedCompoents = importGlob(`/src/layouts/${component}`)\n\n  for (const componentPath in importedCompoents) {\n    output[componentPath] = new Factory(importedCompoents[componentPath])\n  }\n\n  return output\n}\n\nexport { getLayoutCollections }\n","import React, { PropsWithChildren, useMemo } from 'react'\nimport { Factory } from '../utils/Factory'\nimport { getLayoutCollections } from '../utils/getLayoutCollections'\nimport { LazyComponent } from './LazyCompoent'\n\nconst layouts = {\n  headers: getLayoutCollections('headers'),\n  footers: getLayoutCollections('footers'),\n  contents: getLayoutCollections('contents'),\n}\n\nconst LayoutComponent: React.FC<\n  PropsWithChildren<{ component: 'headers' | 'footers' | 'contents'; name: string }>\n> = React.memo(({ name, children, component }) => {\n  const factory: Factory | null = useMemo(() => {\n    const collections = layouts[component]\n    if (name === 'none' || !collections) return null\n\n    return collections[name] || collections['index'] || null\n  }, [component, name])\n\n  if (!factory) return <React.Fragment>{children}</React.Fragment>\n  return <LazyComponent factory={factory}>{children}</LazyComponent>\n})\n\nexport { LayoutComponent }\n","import React, { useMemo, useState } from 'react'\nimport { unstable_HistoryRouter as HistoryRouter, useRoutes } from 'react-router-dom'\nimport styled from 'styled-components'\nimport { CUSTOM_EVENTS } from '../constants/customEvents'\nimport { T_LayoutOptions } from '../hocs/withLayout'\nimport { useHeight } from '../hooks/useHeight'\nimport { watcher } from '../hooks/useWatcher'\nimport { routes } from '../routes'\nimport { history } from '../utils/history'\nimport { LayoutComponent } from './LayoutComponent'\n\ntype T_RouterProvider = React.NamedExoticComponent<{\n  fallback?: React.ReactNode\n}>\n\nconst Router: T_RouterProvider = React.memo(() => {\n  const pathname = history.location.pathname\n  const [layout, setLayout] = useState<Record<string, T_LayoutOptions>>({})\n  const configs = useMemo(() => layout[pathname], [layout, pathname])\n  const [headerRef, headerHeight] = useHeight()\n  const [footerRef, footerHeight] = useHeight()\n\n  watcher.useWatcher<Record<string, T_LayoutOptions>>(CUSTOM_EVENTS.CHANGE_LAYOUTS, (options) => {\n    setLayout((prev) => ({ ...prev, ...options }))\n  })\n\n  return (\n    // @ts-expect-error\n    <HistoryRouter history={history}>\n      {/* <Suspense fallback={fallback}> */}\n      {configs?.header && (\n        <Header ref={headerRef}>\n          <LayoutComponent component=\"headers\" name={configs.header} />\n        </Header>\n      )}\n\n      {configs?.content && (\n        <Main headerHeight={headerHeight} footerHeight={footerHeight}>\n          <LayoutComponent component=\"contents\" name={configs?.content}>\n            <Routes />\n          </LayoutComponent>\n        </Main>\n      )}\n\n      {Boolean(configs?.content) || (\n        <main>\n          <Routes />\n        </main>\n      )}\n\n      {configs?.footer && (\n        <footer ref={footerRef}>\n          <LayoutComponent component=\"footers\" name={configs?.footer} />\n        </footer>\n      )}\n      {/* </Suspense> */}\n    </HistoryRouter>\n  )\n})\n\nexport { Router }\n\nconst Main = styled.main`\n  min-height: ${({\n    headerHeight = 0,\n    footerHeight = 0,\n  }: {\n    headerHeight?: number\n    footerHeight?: number\n  }) => `calc(100vh - ${headerHeight + footerHeight}px)`};\n`\n\nconst Header = styled.header`\n  position: sticky;\n  top: 0;\n  left: 0;\n  background: white;\n  box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n`\n\nconst Routes = React.memo(() => useRoutes(routes))\n","const CUSTOM_EVENTS = {\n  'CHANGE_LAYOUTS': 'CHANGE_LAYOUTS',\n}\n\nexport { CUSTOM_EVENTS }\n","import React, { useLayoutEffect } from 'react'\nimport { useLocation } from 'react-router-dom'\nimport { CUSTOM_EVENTS } from '../constants/customEvents'\nimport { watcher } from '../hooks/useWatcher'\n\ntype T_LayoutOptions = {\n  header?: string\n  content?: string\n  footer?: string\n}\n\nconst withLayout = (Comment: React.FC<any>, options?: T_LayoutOptions) => () => {\n  const { pathname } = useLocation()\n\n  useLayoutEffect(() => {\n    watcher.emitWatcher(CUSTOM_EVENTS.CHANGE_LAYOUTS, {\n      [pathname]: {\n        header: options?.header || 'index',\n        content: options?.content || 'index',\n        footer: options?.footer || 'index',\n      },\n    })\n  }, [])\n\n  return <Comment />\n}\n\nexport { withLayout }\nexport type { T_LayoutOptions }\n"],"names":["useWatcher","name","listener","useEventListener","detail","emitWatcher","data","dispatchEvent","createBrowserHistory","React","memo","Fragment","error","onClick","onReload","LoadingContainer","NcLoading","styled","div","factory","children","useBoolean","isFetched","isLoading","onLoading","setTrue","offLoading","setFalse","useCallback","Promise","all","resolve","fetch","useLayoutEffect","Loading","ChunkLoadError","Component","_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","Symbol","iterator","asyncIterator","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","index","recover","_interrupt","maxTryTimes","console","message","basePath","_","pickBy","import","__val","key","startsWith","replace","output","baseName","Date","now","path","toLowerCase","join","split","importGlob","pathConvert","pagePath","slugConvert","importedPages","push","element","LazyComponent","warn","routes","map","pick","routePreloads","getRoutes","forwardRef","props","forwardedRef","useRef","current","inViewport","useInViewport","ref","useMemo","to","pathname","JSON","stringify","find","r","targetPath","useEffect","currentRoute","DefaultLink","useSize","size","height","component","componentPath","importedCompoents","headers","getLayoutCollections","footers","contents","layouts","collections","history","location","useState","layout","setLayout","useHeight","headerRef","headerHeight","footerRef","footerHeight","watcher","options","prev","HistoryRouter","configs","header","Header","LayoutComponent","content","Main","Routes","Boolean","footer","main","Comment","useLocation"],"mappings":"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"}