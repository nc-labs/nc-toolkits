{"version":3,"file":"index.js","sources":["../src/hooks/useWatcher.tsx","../src/utils/history.tsx","../src/components/LazyCompoent.tsx","../src/utils/delay.tsx","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/components/Loading.tsx","../src/utils/Factory.tsx","../src/utils/getRoutes.tsx","../src/routes.tsx","../src/components/Link.tsx","../src/hooks/useHeight.tsx","../src/utils/getLayoutCollections.tsx","../src/components/LayoutComponent.tsx","../src/components/Router.tsx","../src/constants/customEvents.tsx","../src/hocs/withLayout.tsx"],"sourcesContent":["import { useEventListener } from 'ahooks'\n\nconst watcher = {\n  useWatcher: <T,>(name: string, listener: (data: T) => void) => {\n    // @ts-expect-error\n    useEventListener(name, ({ detail }: { detail: T }) => {\n      listener(detail)\n    })\n  },\n  emitWatcher: <T,>(name: string, data: T) =>\n    window.dispatchEvent(new CustomEvent(name, { detail: data })),\n}\n\nexport { watcher }\n","import { createBrowserHistory } from 'history'\n\nconst history = createBrowserHistory()\nexport { history }\n","import React, { useEffect } from 'react'\nimport { useUpdate } from 'ahooks'\nimport { delay } from '../utils/delay'\nimport { Factory } from '../utils/Factory'\n\nconst LazyComponent: React.FC<React.PropsWithChildren<{ factory: Factory }>> = React.memo(\n  ({ factory, children }) => {\n    const reRender = useUpdate()\n\n    useEffect(() => {\n      if (factory.isFetched) return\n\n      Promise.all([delay(), factory.fetch()]).then(() => reRender())\n    }, [])\n\n    return <factory.Component>{children}</factory.Component>\n  }\n)\n\nexport { LazyComponent }\n","const delay = (ms?: number) => new Promise((resolve) => setTimeout(resolve, ms || 1000))\n\nexport { delay }\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from 'react'\nimport { Loading as NcLoading } from 'nc-simple-loading'\nimport styled from 'styled-components'\n\nconst Loading = React.memo(() => (\n  <LoadingContainer>\n    <NcLoading />\n  </LoadingContainer>\n))\n\nexport { Loading }\n\nconst LoadingContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  z-index: 999999999;\n  background: white;\n  display: flex;\n  align-items: center;\n  justify-contents: space-between;\n`\n","import React from 'react'\nimport { Loading } from '../components/Loading'\nimport { T_Factory } from './lazy'\n\nclass Factory {\n  factory: T_Factory\n  isFetched: boolean = false\n  Component: React.FC<any> = Loading\n  path: string\n\n  constructor(factory: T_Factory, path?: string) {\n    this.factory = factory\n    this.path = path || ''\n  }\n\n  fetch = async () => {\n    const maxTryTimes = 3 // cho phép fetch tối đa 3 lần\n\n    for (let index = 0; index < maxTryTimes; index++) {\n      try {\n        const { default: Component } = await this.factory()\n        this.Component = Component\n        this.isFetched = true\n        break // nếu fetch thành công thì done luôn không cần thử lại\n      } catch (e) {\n        if (index === maxTryTimes - 1) {\n          // đây là lần fetch cuối cùng, tức là 3 lần liên tiếp fetch bị lỗi\n          // TODO viết 1 component thông báo lỗi chunk load và không cố gắng fetch lại\n        }\n\n        // nếu chưa phải lần fetch cuối cùng thì không làm gì cả, để vòng for tự tăng và thử load lại lần nữa\n      }\n    }\n  }\n}\n\nexport { Factory }\n","import React from 'react'\nimport _ from 'lodash'\nimport { LazyComponent } from '../components/LazyCompoent'\nimport { Factory } from './Factory'\nimport { T_Factory } from './lazy'\n\n// TODO xử lý trường hợp 2 slug trùng tên\nconst getRoutes = () => {\n  // @ts-expect-error\n  const importedRoutes: Record<string, T_Factory> = import.meta.glob('/src/pages/**/[a-z[]*.tsx')\n  const output = []\n  // const lazyFunc = lazyFunction || lazy\n\n  for (const key in importedRoutes) {\n    const pathWithSlugRegex = /^(\\/[a-z][^\\]/\\s]*|\\/\\[[a-z][^/\\s]*\\])+$|^\\/$/g\n    let path =\n      key\n        .split(/\\/src\\/pages|\\.tsx$|\\/index\\.tsx$/g)\n        .join('')\n        .toLowerCase() || '/'\n\n    if (!pathWithSlugRegex.test(path)) {\n      console.warn('[nc-toolkits]', key, 'is invalid path.')\n      continue\n    } // không tạo route nếu không đúng định dạng\n\n    path = path.split(/\\]/).join('').split(/\\/\\[/).join('/:') // thay thees /[slug] thành /:slug\n    const factory = new Factory(importedRoutes[key])\n\n    output.push({\n      path,\n      factory,\n      element: <LazyComponent factory={factory} />,\n    })\n  }\n\n  return {\n    routes: output.map((o) => _.pick(o, ['path', 'element'])),\n    routePreloads: output.map((o) => _.pick(o, ['path', 'factory'])),\n  }\n}\n\nexport { getRoutes }\n","import { getRoutes } from './utils/getRoutes'\n\nconst { routes, routePreloads } = getRoutes()\n\nexport { routePreloads, routes }\n","import React, { useEffect, useMemo, useRef } from 'react'\nimport { useInViewport } from 'ahooks'\nimport { matchPath, Link as DefaultLink } from 'react-router-dom'\nimport { routePreloads } from '../routes'\n\nconst Link: typeof DefaultLink = React.memo(\n  React.forwardRef((props, forwardedRef) => {\n    // @ts-expect-error\n    const ref = useRef(forwardedRef?.current || forwardedRef || null)\n    const [inViewport] = useInViewport(ref)\n\n    const targetPath: string = useMemo(\n      () => (typeof props.to === 'string' ? props.to : props.to.pathname) as string,\n      [JSON.stringify(props.to)]\n    )\n\n    const currentRoute = useMemo(\n      () => routePreloads.find((r) => matchPath(r.path, targetPath)),\n      [targetPath]\n    )\n\n    useEffect(() => {\n      if (!inViewport) return // không thực hiện nếu link chưa hiển thị trên màn hình\n      if (!currentRoute || !currentRoute.factory) return // không thực hiện nếu không tìm được route\n      if (currentRoute.factory.isFetched) return // không thực hiện gì nếu đã được preload\n\n      currentRoute.factory.fetch()\n    }, [inViewport])\n\n    return <DefaultLink {...props} ref={ref} />\n  })\n)\n\nexport { Link }\n","import { useMemo, useRef } from 'react'\nimport { useSize } from 'ahooks'\n\nconst useHeight = (): [React.MutableRefObject<null>, number] => {\n  const ref = useRef(null)\n  const size = useSize(ref)\n  const height = useMemo(() => size?.height || 0, [size])\n  return [ref, height]\n}\n\nexport { useHeight }\n","import { Factory } from './Factory'\nimport { T_Factory } from './lazy'\n\nconst getCollectionByType = (\n  type: 'headers' | 'footers' | 'contents'\n): Record<string, T_Factory> => {\n  switch (type) {\n    case 'headers':\n      // @ts-expect-error\n      return import.meta.glob('/src/layouts/headers/*.tsx')\n    case 'footers':\n      // @ts-expect-error\n      return import.meta.glob('/src/layouts/footers/*.tsx')\n    case 'contents':\n      // @ts-expect-error\n      return import.meta.glob('/src/layouts/contents/*.tsx')\n    default:\n      return {}\n  }\n}\n\nconst getLayoutCollections = (component: 'headers' | 'footers' | 'contents') => {\n  const output: Record<string, Factory> = {}\n  const importedCompoents = getCollectionByType(component)\n\n  for (const key in importedCompoents) {\n    const parsedKey =\n      key.split(new RegExp(`/src/layouts/${component}/|.tsx$|/index.tsx$`, 'g')).join('') || 'index'\n    output[parsedKey] = new Factory(importedCompoents[key])\n  }\n\n  return output\n}\n\nexport { getLayoutCollections }\n","import React, { PropsWithChildren, useMemo } from 'react'\nimport { Factory } from '../utils/Factory'\nimport { getLayoutCollections } from '../utils/getLayoutCollections'\nimport { LazyComponent } from './LazyCompoent'\n\nconst layouts = {\n  headers: getLayoutCollections('headers'),\n  footers: getLayoutCollections('footers'),\n  contents: getLayoutCollections('contents'),\n}\n\nconst LayoutComponent: React.FC<\n  PropsWithChildren<{ component: 'headers' | 'footers' | 'contents'; name: string }>\n> = React.memo(({ name, children, component }) => {\n  const factory: Factory | null = useMemo(() => {\n    const collections = layouts[component]\n    if (name === 'none' || !collections) return null\n\n    return collections[name] || collections['index'] || null\n  }, [component, name])\n\n  if (!factory) return <React.Fragment>{children}</React.Fragment>\n  return <LazyComponent factory={factory}>{children}</LazyComponent>\n})\n\nexport { LayoutComponent }\n","import React, { Suspense, useMemo, useState } from 'react'\nimport { unstable_HistoryRouter as HistoryRouter, useRoutes } from 'react-router-dom'\nimport styled from 'styled-components'\nimport { CUSTOM_EVENTS } from '../constants/customEvents'\nimport { T_LayoutOptions } from '../hocs/withLayout'\nimport { useHeight } from '../hooks/useHeight'\nimport { watcher } from '../hooks/useWatcher'\nimport { routes } from '../routes'\nimport { history } from '../utils/history'\nimport { LayoutComponent } from './LayoutComponent'\n\ntype T_RouterProvider = React.NamedExoticComponent<{\n  fallback?: React.ReactNode\n}>\n\nconst Router: T_RouterProvider = React.memo(({ fallback }) => {\n  const pathname = history.location.pathname\n  const [layout, setLayout] = useState<Record<string, T_LayoutOptions>>({})\n  const configs = useMemo(() => layout[pathname], [layout, pathname])\n  const [headerRef, headerHeight] = useHeight()\n  const [footerRef, footerHeight] = useHeight()\n\n  watcher.useWatcher<Record<string, T_LayoutOptions>>(CUSTOM_EVENTS.CHANGE_LAYOUTS, (options) => {\n    setLayout((prev) => ({ ...prev, ...options }))\n  })\n\n  return (\n    // @ts-expect-error\n    <HistoryRouter history={history}>\n      <Suspense fallback={fallback}>\n        {configs?.header && (\n          <Header ref={headerRef}>\n            <LayoutComponent component=\"headers\" name={configs.header} />\n          </Header>\n        )}\n\n        {configs?.content && (\n          <Main headerHeight={headerHeight} footerHeight={footerHeight}>\n            <LayoutComponent component=\"contents\" name={configs?.content}>\n              <Routes />\n            </LayoutComponent>\n          </Main>\n        )}\n\n        {Boolean(configs?.content) || (\n          <main>\n            <Routes />\n          </main>\n        )}\n\n        {configs?.footer && (\n          <footer ref={footerRef}>\n            <LayoutComponent component=\"footers\" name={configs?.footer} />\n          </footer>\n        )}\n      </Suspense>\n    </HistoryRouter>\n  )\n})\n\nexport { Router }\n\nconst Main = styled.main`\n  min-height: ${({\n    headerHeight = 0,\n    footerHeight = 0,\n  }: {\n    headerHeight?: number\n    footerHeight?: number\n  }) => `calc(100vh - ${headerHeight + footerHeight}px)`};\n`\n\nconst Header = styled.header`\n  position: sticky;\n  top: 0;\n  left: 0;\n  background: white;\n  box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n`\n\nconst Routes = React.memo(() => useRoutes(routes))\n","const CUSTOM_EVENTS = {\n  'CHANGE_LAYOUTS': 'CHANGE_LAYOUTS',\n}\n\nexport { CUSTOM_EVENTS }\n","import React, { useLayoutEffect } from 'react'\nimport { useLocation } from 'react-router-dom'\nimport { CUSTOM_EVENTS } from '../constants/customEvents'\nimport { watcher } from '../hooks/useWatcher'\n\ntype T_LayoutOptions = {\n  header?: string\n  content?: string\n  footer?: string\n}\n\nconst withLayout = (Comment: React.FC<any>, options?: T_LayoutOptions) => () => {\n  const { pathname } = useLocation()\n\n  useLayoutEffect(() => {\n    watcher.emitWatcher(CUSTOM_EVENTS.CHANGE_LAYOUTS, {\n      [pathname]: {\n        header: options?.header || 'index',\n        content: options?.content || 'index',\n        footer: options?.footer || 'index',\n      },\n    })\n  }, [])\n\n  return <Comment />\n}\n\nexport { withLayout }\nexport type { T_LayoutOptions }\n"],"names":["useWatcher","name","listener","useEventListener","detail","emitWatcher","data","dispatchEvent","createBrowserHistory","React","memo","factory","children","useUpdate","useEffect","isFetched","Promise","all","resolve","fetch","then","Component","_Pact","prototype","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","Symbol","iterator","asyncIterator","LoadingContainer","NcLoading","styled","div","path","Loading","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","index","recover","_interrupt","import","key","split","join","toLowerCase","importedRoutes","output","push","element","LazyComponent","console","warn","routes","map","pick","routePreloads","getRoutes","forwardRef","props","forwardedRef","useRef","current","inViewport","useInViewport","ref","useMemo","to","pathname","JSON","stringify","find","r","targetPath","currentRoute","DefaultLink","useSize","size","height","component","type","getCollectionByType","importedCompoents","headers","getLayoutCollections","footers","contents","layouts","collections","Fragment","fallback","history","location","useState","layout","setLayout","useHeight","headerRef","headerHeight","footerRef","footerHeight","watcher","options","prev","HistoryRouter","Suspense","configs","header","Header","LayoutComponent","content","Main","Routes","Boolean","footer","main","Comment","useLocation","useLayoutEffect"],"mappings":"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"}